{
  "name": "FluentModelBuilder",
  "tagline": "Fluently configure EntityFramework Core DbContext",
  "body": "# Introducing FluentModelBuilder\r\n\r\n## What is it\r\nIf you're writing an application with .NET Core using Entity Framework Core, you may want to have a better way of customising your backing model. `FluentModelBuilder` is a drop-in extension for doing exactly that in a fluent manner. It plugs itself into Entity Framework Core's own pipeline and even plays nice with dependency injection. There's a variety of extension points that allow configuring your model in a very conventional and automated way which should be very familiar if you come from Fluent NHibernate background.\r\n\r\n## Installation\r\nNuGet:\r\n```c#\r\nInstall-Package FluentModelBuilder\r\n```\r\n\r\nIf you want Relational Conventions:\r\n```c#\r\nInstall-Package FluentModelBuilder.Relational\r\n```\r\n\r\n## How to use\r\nTo extend your pre-existing DbContext, just use `Configure` inside `AddDbContext<TContext>()`:\r\n\r\n```c#\r\n// Scan assembly of YourContext for entities\r\n\r\nservices.AddDbContext<YourContext>(opt => \r\n    opt\r\n        .UseSqlServer(\"\")\r\n        .Configure(fluently => \r\n            fluently\r\n                .Using(type => type.Namespace.EndsWith(\"Entities\"))\r\n                .AddEntitiesFromAssemblyOf<YourContext>()));\r\n```\r\n\r\nFor more complex configuration, implement `IEntityAutoConfiguration` or subclass from `DefaultEntityAutoConfiguration`:\r\n\r\n```c#\r\n// Pick up all concrete types that inherit from Entity\r\npublic class MyEntityAutoConfiguration : DefaultEntityAutoConfiguration\r\n{\r\n    public override bool ShouldMap(Type type)\r\n    {\r\n        return base.ShouldMap(type) && type.GetTypeInfo().IsSubClassOf(typeof(Entity));\r\n    }\r\n}\r\n\r\n// Configure service\r\nservices.AddDbContext<YourContext>(opt => \r\n    opt\r\n        .UseSqlServer(\"\")\r\n        .Configure(fluently =>\r\n            fluently\r\n                .Using(new MyEntityAutoConfiguration())\r\n                .AddEntitiesFromAssemblyOf<YourContext>()));\r\n```\r\n\r\nYou can also use it in your DbContext's configure method. Example given using `From` entry point\r\n\r\n```c#\r\n// Inside DbContext\r\nprotected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\r\n{\r\n    optionsBuilder.Configure(\r\n        From.AssemblyOf<YourContext>(new MyEntityAutoConfiguration()));\r\n}\r\n```\r\n\r\nIf you want to put all your entity maps into separate files, implement `IEntityTypeOverride<T>` and add the assembly for overrides:\r\n\r\n```c#\r\npublic class MyEntityOverride : IEntityTypeOverride<MyEntity>\r\n{\r\n    public void Override(EntityTypeBuilder<MyEntity> mapping)\r\n    {\r\n        mapping.ToTable(\"MyEntities\");\r\n    }\r\n}\r\n\r\n// From-syntax, without the Configure() bit\r\n\r\nFrom\r\n    .AssemblyOf<YourContext>(new MyEntityAutoConfiguration())\r\n    .UseOverridesFromAssemblyOf<YourContext>();\r\n\r\n```\r\n\r\n### Dependency Injection\r\n\r\nFluentModelBuilder adds a different way of altering your model and model builder programmatically using the application's service provider. When implementing interfaces `ITypeSource`, `IModelBuilderAlteration`, or `IModelBuilderConvention`, you can use constructor injection to retrieve dependencies. You'll also need to ensure that relevant Entity Framework services are added to your service provider.\r\n\r\n```c#\r\n// Alteration\r\npublic class MyAlteration : IAutoModelBuilderAlteration\r\n{\r\n    private IDependency _dependency;\r\n    public MyAlteration(IDependency dependency)\r\n    {\r\n        _dependency = dependency;\r\n    }\r\n\r\n    public void Alter(AutoModelBuilder autoModelBuilder)\r\n    {\r\n        // .. Do something with dependency\r\n    }\r\n}\r\n\r\n// Type Source\r\npublic class MyTypeSource : ITypeSource\r\n{\r\n    private IDependency _dependency;\r\n    public MyTypeSource(IDependency dependency)\r\n    {\r\n        _dependency = dependency;\r\n    }\r\n\r\n    public IEnumerable<Type> GetTypes()\r\n    {\r\n        // .. do something with dependency\r\n    }\r\n}\r\n\r\n// Convention\r\npublic class MyConvention : IModelBuilderConvention\r\n{\r\n    private IDependency _dependency;\r\n    public MyConvention(IDependency dependency)\r\n    {\r\n        _dependency = dependency;\r\n    }\r\n\r\n    public void Apply(ModelBuilder modelBuilder)\r\n    {\r\n        // .. do something with dependency\r\n    }\r\n}\r\n\r\n// Configure services\r\nservices\r\n    .AddEntityFrameworkInMemoryDatabase()\r\n    .AddDbContext<DbContext>((sp, x) => x.UseInMemoryDatabase().UseInternalServiceProvider(sp));\r\nservices.ConfigureEntityFramework(f => f.Using()\r\n    .AddAlteration<MyAlteration>()\r\n    .AddTypeSource<MyTypeSource>()\r\n    .UseConvention<MyConvention>());\r\nservices.AddScoped<IDependency, MyDependency>();\r\n```\r\n\r\n`Alter()` will execute prior to `GetTypes()`, which will execute before `Apply()`, and all three of them will have access to the dependency. As DbContext is capable of creating its own scope, the dependencies can be singletons, transient, or scoped.\r\n\r\n### Conventions\r\nFluentModelBuilder has some degree of convention support. Currently there is a `DecimalPropertyConvention` and `PluralizingTableNameGeneratingConvention`. Those can be added like this:\r\n\r\n```c#\r\nFrom.AssemblyOf<YourContext>(new MyEntityConfiguration())\r\n    .UseConvention(new DecimalPropertyConvention())\r\n    .UseConvention<PluralizingTableNameGeneratingConvention>();\r\n```\r\n\r\n\r\nYou can also inherit from `AbstractEntityConvention` which applies itself to every entity inside the currently built model.",
  "google": "UA-69079635-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}